"""
The python implementation of last layer of mobilenet in caffe.
It can process the feature map generated by convolution layer to get the detection box, label and confidence.
"""


import numpy as np
from math import *


class blob:
    """
    this class is the data structure used by caffe to store the feature map
    need to initialize the blob with the feature map, call blob("feature_map") for initialization
    """
    def __init__(self, array):
        self.data = array
        self.shape = array.shape

    def num(self):
        return self.shape[0]

    def channel(self):
        return self.shape[1]

    def height(self):
        return self.shape[2]

    def width(self):
        return self.shape[3]

    def reshape(self, n, k, w, h):
        shape = [n, k, w, h]
        self.data = np.reshape(self.data, shape)
        self.shape = shape


class PredictionResult:
    """
    class used to store the prediction results
    """
    def __init__(self):
        self.x = 0
        self.y = 0
        self.w = 0
        self.h = 0
        self.objScore = 0
        self.classScore = 0
        self.confidence = 0
        self.classType = 0
        self.data = [self.x,self.y,self.w,self.h,self.objScore,self.classScore,self.confidence,self.classType]

    def update(self, x=0, y=0, w=0, h=0, objScore=0, classScore=0, confidence=0, classType = 0):
        self.x = x if x != 0 else self.x
        self.y = y if y != 0 else self.y
        self.w = w if w != 0 else self.w
        self.h = h if h != 0 else self.h
        self.objScore = objScore if objScore != 0 else self.objScore
        self.classScore = classScore if classScore != 0 else self.classScore
        self.confidence = confidence if confidence != 0 else self.confidence
        self.classType = classType if classType != 0 else self.classType
        self.data = [self.x,self.y,self.w,self.h,self.objScore,self.classScore,self.confidence,self.classType]


class NormalizedBBox:
    """
    class used for storing the box
    """
    def __init__(self):
        self.box = [0, 0, 1, 1]
        self.xmin = 0
        self.xmax = 0
        self.ymin = 0
        self.ymax = 0
        self.size = 0

    def set_xmin(self, value):
        self.xmin = value
        self.box[0] = value

    def set_xmax(self, value):
        self.xmax = value
        self.box[2] = value

    def set_ymin(self, value):
        self.ymin = value
        self.box[1] = value

    def set_ymax(self, value):
        self.ymax = value
        self.box[3] = value

    def set_size(self,value):
        self.size = value


def BBoxSize(bbox, normalized):
    """
    :param bbox: prediction box (NormalizedBbox)
    :param normalized: bool value, ture for normalized Bbox
    :return: calculated area
    """
    """
    function that calculate the size of the prediction box
    """
    if bbox.xmax < bbox.xmin and bbox.ymax < bbox.ymin:
        return 0
    else:
        if bbox.size != 0:
            return bbox.size
        else:
            width = bbox.xmax - bbox.xmin
            height = bbox.ymax - bbox.ymin
            if normalized:
                return width * height
            else:
                return (width + 1) * (height + 1)


def sigmoid(x):
  return 1 / (1 + exp(-x))


def overlap(x1, w1, x2, w2):
    """
    :param x1: minimum coordinate (x or y) of box 1
    :param w1: width or height of box 1
    :param x2: minimum coordinate (x or y) of box 2
    :param w2: width or height of box 2
    :return: the overlapped length
    """
    l1 = x1 - w1/2
    l2 = x2 - w2/2
    left = l1 if l1 > l2 else l2
    r1 = x1 + w1/2
    r2 = x2 + w2/2
    right = r1 if r1 < r2 else r2
    return right - left


def box_intersection(a, b):
    """
    :param a: box a
    :param b: box b
    :return: the intersected area of two boxes
    """
    w = overlap(a[0],a[2],b[0],b[2])
    h = overlap(a[1],a[3],b[1],b[3])
    if w < 0 and h < 0:
        return 0
    area = w*h
    return area


def box_union(a, b):
    """
    :param a: box a
    :param b: box b
    :return: the total area of two boxes
    """
    i = box_intersection(a, b)
    u = a[2] * a[3] + b[2] * b[3] - i
    return u


def box_iou(a, b):
    """
    function that take two prediction boxes
    and return the percentage of intersected area to the total area (iou)
    :param a: box a
    :param b: box b
    :return: the iou value
    """
    return box_intersection(a, b) / box_union(a, b)


def setNormalizedBBox(bbox, x, y, w, h):
    """
    :param bbox: prediction box (NormalizedBBox)
    :param x: the minimum x coordinate
    :param y: the minimum y coordinate
    :param w: width
    :param h: height
    :return: the updated prediction box (NormalizedBBox)
    """
    xmin = x - w / 2.0 if (x - w / 2.0) > 0 else 0.0
    xmax = x + w / 2.0 if (x + w / 2.0) < 1 else 1.0
    ymin = y - h / 2.0 if (y - h / 2.0) > 0 else 0.0
    ymax = y + h / 2.0 if (y + h / 2.0) < 1 else 1.0

    bbox.set_xmin(xmin)
    bbox.set_xmax(xmax)
    bbox.set_ymin(ymin)
    bbox.set_ymax(ymax)
    bbox_size = BBoxSize(bbox, True)
    bbox.set_size(bbox_size)
    return bbox


def ApplyNms(boxes, idxes, threshold):
    """
    :param boxes: list of calculated boxes
    :param idxes: list of indices
    :param threshold: threshold for iou
    :return: the updated idxes list with prediction boxes
    """
    idex_map = [0]*len(boxes)
    for i in range (0, len(idex_map)-1):
        if idex_map[i] != 0:
            continue
        for j in range(i+1, len(idex_map)):
            if idex_map[j] != 0:
                continue
            Bbox1, Bbox2 = [], []
            Bbox1.append(boxes[i].x)
            Bbox1.append(boxes[i].y)
            Bbox1.append(boxes[i].w)
            Bbox1.append(boxes[i].h)

            Bbox2.append(boxes[j].x)
            Bbox2.append(boxes[j].y)
            Bbox2.append(boxes[j].w)
            Bbox2.append(boxes[j].h)

            iou = box_iou(Bbox1, Bbox2)
            if iou >= threshold:
                idex_map[j] = 1

    for i in range(0, len(boxes)):
        if idex_map[i] == 0:
            idxes.append(i)

    return idxes


def class_index_score(input, classes, predict):
    """
    :param input: feature map (numpy array)
    :param classes: number of classes (int)
    :param predict: prediction (PredictionResult)
    :return: upadted PredictionResult with class and confident score
    """
    sum = 0
    large = input[0]
    classIndex = 0
    for i in range(0, classes-1):
        if input[i] > large:
            large = input[i]
    for i in range(0, classes-1):
        e = exp(input[i] - large)
        sum += e
        input[i] = e

    for i in range(0, classes-1):
        input[i] = input[i] / sum


    large = input[0]

    for i in range(0, classes-1):

        if input[i] > large:
            large = input[i]
            classIndex = i


    predict.update(classType = classIndex)
    predict.update(classScore = large)

    return predict


def get_region_box(input, predict, biases, n, index, i, j, w, h):
    """
    :param input: feature map (numpy array)
    :param predict: prediction result
    :param biases: biases
    :param n: index of preset number of boxes
    :param index: index
    :param i: index of row
    :param j: index or column
    :param w: width of feature map
    :param h: height of feature map
    :return: updated prediction result
    """
    predict.update(x=(i + sigmoid(input[index+0])) / w,
                   y=(j + sigmoid(input[index+1])) / h,
                   w=exp(input[index + 2]) * biases[2*n] / w,
                   h=exp(input[index + 3]) * biases[2*n + 1] / h)

    return predict


def set_up_detection_out(input, num_classes, coords =4, confidence_threshold = 0.4, nms_threshold = 0.4,
                         biases = [1.578, 3.456, 2.330, 2.096, 3.835, 2.885, 2.586, 4.704, 1.475, 1.396], num_box=5):
    """
    set_up_detection_out is the function should be used
    :param input: feature map from convolution layer
    :param num_classes: total number of labels + 1 for background
    :param coords: default is 4
    :param confidence_threshold: default is 0.4, confident threshold for keeping the predictions
    :param nms_threshold: default is 0.4, threshold for merging prediction boxes
    :param biases: default is [1.578, 3.456, 2.330, 2.096, 3.835, 2.885, 2.586, 4.704, 1.475, 1.396]
    :param num_box: default is 5
    :return: the processed result which contains the information about prediction boxes, labels, confident score
    """
    num = input.num()
    side_ = input.width()
    height = input.height()
    width = input.width()
    channel = input.channel()
    swap_data = np.zeros(num*height * width * channel)
    index = 0
    b = 0
    while b < num:
        for h in range(0, height):
            for w in range(0, width):
                for c in range(0, channel):
                    swap_data[index] = input.data[b,c,h,w]
                    index += 1
        b += 1
    swap = blob(swap_data)
    swap.reshape(num, height * width, num_box, int(channel/num_box))
    predicts = []
    b = 0
    while b < num:
        for j in range(0, side_):
            for i in range(0, side_):
                for n in range(0, num_box):
                    predict = PredictionResult()
                    index = b * swap.channel() * swap.height() * swap.width() + (j * side_ + i) * swap.height() * swap.width() + n * swap.width()

                    predict = get_region_box(swap_data, predict, biases, n, index, i, j, side_, side_)

                    predict.update(objScore=sigmoid(swap_data[index+4]))

                    predict = class_index_score(swap_data[index + 5:], num_classes, predict)

                    predict.update(confidence=predict.objScore * predict.classScore)

                    if predict.confidence >= confidence_threshold:

                        if predicts == []:
                            predicts.append(predict)
                        elif predict.confidence > predicts[0].confidence:
                            predicts = [predict]+predicts
                        elif predict.confidence < predicts[0].confidence:
                            bo = True
                            for i in range(1,len(predicts)):
                                if predict.confidence > predicts[i].confidence:
                                    predicts = predicts[0:i-1]+[predict]+predicts[i+1:]
                                    bo = False
                                    break
                            if bo:
                                predicts.append(predict)

        b += 1

    idxes = []
    num_kept = 0
    if len(predicts) >0:
        idxes = ApplyNms(predicts, idxes, nms_threshold)
        num_kept = len(idxes)
    if input.num() > 1:
        num = 1

    output = np.zeros(7*num_kept)
    i = 0
    while i < num_kept:
        output[i*7] = 0
        output[i * 7 + 1] = predicts[idxes[i]].classType + 1
        output[i * 7 + 2] = predicts[idxes[i]].confidence
        left = (predicts[idxes[i]].x - predicts[idxes[i]].w / 2.)
        right = (predicts[idxes[i]].x + predicts[idxes[i]].w / 2.)
        top = (predicts[idxes[i]].y - predicts[idxes[i]].h / 2.)
        bot = (predicts[idxes[i]].y + predicts[idxes[i]].h / 2.)
        output[i * 7 + 3] = left
        output[i * 7 + 4] = top
        output[i * 7 + 5] = right
        output[i * 7 + 6] = bot
        i += 1
    output = output.reshape([1,1,num_kept,7])
    return output
